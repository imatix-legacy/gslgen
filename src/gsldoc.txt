The Generator Script Language
*****************************

Author:
  iMatix Corporation <tools@imatix.com>
Revised:
  2000/02/15

Introduction
************

What is GSL?

- Generator Script Language (GSL) is a simple and powerful scripting
language designed to work with data from Extensible Markup Language
(XML) files.
- GSL is interpreted by GSLgen, either as a stand-alone tool or integrated
into an application.

What can GSL do?

- GSLgen is a general-purpose file generator.
- GSL is a powerful tool for transforming XML.
- GSLgen is a reporting tool.
- GSL is a web scripting language (integrated into the Xitami
 web server).

To use GSLgen, you should be comfortable with the basic concepts of the
Extensible Markup Language (XML).  However, GSLgen does not use DTDs,
stylesheets, or the other many layers that can render XML complex to use.
When you use GSLgen, XML can be as simple as `<hello>world</hello>'.

What are the alternatives?

- A lot of work by hand.

Copyright and Distribution
==========================

GSLgen is copyright (c) 1996-2000 iMatix Corporation, and is distributed
under an Open Source license as described in the file license.txt that is
supplied with GSLgen.  This license basically grants you the right to use
GSLgen for any purpose, and to distribute modified copies of GSLgen without
restriction.  To conform with the license agreement you should acknowledge
the use of GSLgen in your commercial products.


Installing GSLgen
*****************

GSLgen is provided as a ready-to-run executable for Windows (95/98 and NT),
OS/2 (requires EMX), and Linux.  For other platforms you can rebuild GSLgen
from the provided sources very easily.  Install and build the SFL library
from imatix.com, then build GSLgen using the `build' script provided in the
src subdirectory.  You do need to copy libsfl and sfl.h from the SFL
directory into the src subdirectory.

Using GSLgen 
************

Command-line Syntax
-------------------

To run GSLgen, use the following syntax
    gslgen -<option> ... -<attr>[:<value>] ... filename ...

If the filename has no extension, GSLgen tries to find an XML file with
that name, or with the extension `.xml' (recognised by the <?xml... tag on
the first line).  If it finds no XML file it tries to find a file with
that name or the extension `.gsl', which it interprets as a GSL file.

Options currently recognised by GSLgen are:

q, quiet:
    Suppresses copyright and other messages from GSLgen.

Command-line attributes are loaded with an XML file and are available to
a script.  This allows paramaters to be passed from the command line to the
script.  The attribute script can be set to the name of a GSL file to be
interpreted.

If GSLgen found an XML file, it loads it, then looks for an attribute named
script of the top-level item.  This name is used to find a GSL script to
interpret.  If GSLgen found a GSL file, it begins interpreting it without
loading an XML file.

Getting Started
---------------

How do I use GSLgen?

- If you have an XML file entitled test.xml, the simplest way to
invoke GSLgen is

    gslgen test

- In this case the script must be defined as an attribute of the top-level
  item defined in test.xml.  If this is not the case, or if you wish to
  use a different script, use the form

    gslgen -script:xxxxxxx.gsl test.xml

A Hello World Example
---------------------

Try a `hello world' test:

Create a file called `hello.gsl':

    echo "hello world"

Run this using `gslgen hello'.  This shows a trivial GSL script running
without any XML data.  The script does some work, and ends.  Let's look at
how we process an XML data file.

Create a file called `hello.xml':

    <HWML>
    <WORLD NAME="World">
        <HELLO NAME="Hello" />
    </WORLD>
    </HWML>

Change `hello.gsl' (we now use a dot in the first column):

    .for world
    .  for hello
    .    echo "$(name) $(world.name)"
    .  endfor
    .endfor

Then, run GSLgen:

    gslgen -script:hello.gsl hello.xml


A More Complex Example
----------------------

This is a script which generates a simple DOS batch file to install programs
by copying them into various directories.  It's something you might want to
generate for specific projects:

    .-
    .- install.gsl   Generates install script from install.xml
    .-
    .output "install.bat"
    @echo off
    rem generated by gslgen from install.xml, $(script)
    .for file
    .  if    type = "binary"
    echo $(name) -- \\usr\\bin
    copy $(name) \\usr\\bin >nul
    .  elsif type = "script"
    echo $(name) -- \\usr\\lib
    copy $(name) \\usr\\lib >nul
    .  elsif type = "doc"
    echo $(name) -- \\usr\\doc
    copy $(name) \\usr\\doc >nul
    .  endif
    copy $(name) install >nul
    .endfor

The input is an XML file like this:

    <?xml version="1.0"?>
    <INSTALL script="install.gsl">
    <FILE name="gslgen.exe"  type="binary" />
    <FILE name="gslgen.htm"  type="doc"    />
    <FILE name="install.gsl" type="script" />
    <FILE name="hello.gsl"   type="script" />
    </INSTALL>

We run GSLgen to process the XML file:

    gslgen install

This is the result:

    @echo off
    rem generated by gslgen from install.xml, install.gsl
    echo gslgen.exe -- \usr\bin
    copy gslgen.exe \usr\bin >nul
    copy gslgen.exe install >nul
    echo gslgen.htm -- \usr\doc
    copy gslgen.htm \usr\doc >nul
    copy gslgen.htm install >nul
    echo install.gsl -- \usr\lib
    copy install.gsl \usr\lib >nul
    copy install.gsl install >nul
    echo hello.gsl -- \usr\lib
    copy hello.gsl \usr\lib >nul
    copy hello.gsl install >nul

What's Going On?
----------------

The scripts hello.gsl and install.gsl contain lines with a point (`.')
in the first column.  These are called script lines and contain
instructions to be interpreted.  The script install.gsl also contains
lines which do not begin with a point.  These are called template
lines and contain text to be output when the line is interpreted.
They may also contain substitution symbols which look like the text
`$(name)'.  Notice that each occurrence of the backslash character is
repeated in the script, but not in the output file.  This is because
GSLgen, like many programs, uses the backslash to introduce a special
character, and two backslashes are required to output one backslash.

The `for' instruction requires some explanation; it is the way to
iterate through XML data.  This is somewhat redundant in the case of
`hello.gsl' since there is only one instance of the XML items `WORLD'
and `HELLO'.  The `for' instruction makes available the attributes of
the XML item of the same name.  Thus the attributes `name' and `type'
of the items  named `FILE' in `install.xml' can be used in the lines
between the `for' and corresponding `endfor'.  Notice that in the
first example, the items `WORLD' and `HELLO' both contain an attribute
`NAME' which the script accesses independently by specifying
`$(world.name)' or `$(name)'.  It could also use `$(hello.name)' in
the second case; if the attribute name appears alone then GSLgen
searches for an attribute with that name in all open XML items
beginning with the most recently opened.

Another Complex Example
-----------------------

Try this command:

    gslgen -script:xmlfile.gsl spfper.dbm

This generates a C function, spfper.c, which handles a data table (in this
case a list of persons) as an XML file, with functions to read, save, and
update data in this table.  This is a good example of a complex GSL script,
and one that is used in real life to handle data objects in iMatix Studio.

The General Schema Language (GSL) 
*********************************

Description
===========

GSL is a scripting language developed by iMatix Corporation. It was first
designed as a schema language for code generation and has grown into a
powerful tool for manipulating XML data.

GSL is related to a reporting language such as is used to
generate reports from a relational database, in that it provides a mechanism
for iterating through the data, performing calculations and outputing text
based on the data. Unlike a reporting language it can also manipulate, create,
load and save data.

Many GSL concepts are borrowed directly from database terminology, to which
it is closely related.

Important Concepts
==================

Data Types
----------

GSL recognises two data types: numeric and string.  It makes no formal
distinction between them; if a value looks numeric then it is treated
as such, otherwise it is treated as a string.

Constants
---------

A string constant is specified with either single- or double-quotes as
delimiters, for example: "ABC".   String constants may continue over
several source lines.  The line break is considered part of the string
constant, unless the last character in the line is a single backslash
(`\') in which case neither the backslash nor the line break is part
of the string.  A numeric constant is a simple number with an optional
sign and optional decimal characters, for example 123 and -0.3.

Scopes
------

A scope corresponds to an XML item or, more precisely, it is the presentation
of an XML item to a piece of GSL script.  It typically, although not
necessarily, has the same name as the XML item.  A scope is created by the
`for' and `new' instructions and closed by the corresponding `endfor' and
`endnew'.  In between these lines, the value and attributes of the XML item
can be defined and accessed.  Child items (henceforth children) of the XML
item can also be made available by introducing another scope with another
`for' instruction.

At the start of processing of a script, two scopes are implicitly
defined by GSLgen.  The first corresponds to the top-level item of the
XML file.  We refer to this scope as the root scope.  The second is
named `global' and holds the predefined identifiers (see below) and
command-line switches.  Because these scopes are opened in this order,
command-line switches take precedence over attributes of the root XML
item when no scope name is specified.

Scopes may be referred to by name or by number.  A positive number
refers to the index of the scope starting from the first opened scope.
A negative number or zero refers to the index of the scope relative to
the most recently opened scope.  One more complication:

Extended Scopes
---------------

An extended scope also corresponds to an XML item.  In its simplest
form it is just a scope specification.  It may also contain any number
of `member' specifications (`->'); these refer to children of the XML
item, their children, and so on.  This allows you to avoid introducing
a new scope to access an only child or when you are only interested in
the first child of that name.

Some examples of extended scopes:

    world

The simplest form - this refers to a scope named `world'.

    .

Shorthand for the most recently opened scope.

    1-> field

The first child named `field' of the XML item corresponding to the
first open scope.

    -> parent-> baby

The first child named `baby' of the first child named `parent' of the
XML item corresponding to the most recently opened scope.

Identifiers
-----------

GSL identifiers refer to XML attribute or item values.  (An item value
is the text between its open and close tags.)  It generally consists of an
extended scope specification and an attribute name.  If the attribute name is
missing then the identifier refers to the item value.  There are also some
short-hand forms.

There are a total of five different forms of identifier specification:

<extended-scope>.<attr>:
    A full attribute specification.
<attr>:
    An attribute specification with no scope specified.  In this case GSL
    will search for an attribute with the given name in all the open scopes,
    starting with the most recently opened.
.<attr>:
    An attribute specification with an empty scope specification.  This refers
    to the specified attribute in the most recently opened scope and is
    equivalent to `0.<attr>'.
<extended-scope>.:
    An item value specification.  This refers to the value of
    the XML item referred to by the extended scope specification.
.:
    An item value specification with no scope specified.  This refers 
    to the value of the item corresponding to the most recently opened scope.

To avoid clashes with GSL reserved words, the names of scopes, attributes
and items may be enclosed in square brackets, for example: [for].

Some examples:

TABLE.FIELD:
LENGTH:
.NAME:
TABLE-> INDEX. FIELD:
.:
[OUTPUT].

Case Sensitivity
----------------

GSLgen has two modes of handling the case of XML item and attribute
names.  In the default mode, GSLgen matches names without regard to
the case (upper or lower) used to specify them.  In certain
substitutions  GSLgen modifies the case of the value of the identifier
to match the case used to specify the attribute name.  In
case-sensitive mode, GSLgen matches names taking into account the
case, and does not modify the case of the result.  See the description
of subsitutions for details.

To change modes, set the value of the identifier `ignorecase' in the
global scope to 0 or 1.  Eg: `global.ignorecase = 0'

Expressions
-----------

GSL expressions are much the same as expressions in other high-level
programming languages.  They include the following operators:

Multiplicative:
    *, /
Additive:
    +, -
Default:
    ?
Comparative:
    =, <>, >, >=, <, <=
Safe comparative:
    ?=, ?<>, ?>, ?>=, ?<, ?<=
Logical:
    |, &, !

Operator precedence is standard (multiplicative, additive, default, 
comparative, logical) and brackets are treated as you would expect.

Logical operators treat zero as FALSE and non-zero as TRUE.

GSLgen optimises expression evaluation to the extent that the second
operand of a binary logical operator (`|', `&') is not evaluated if
the result of the expression is determined by the first operand.  This
allows you to use expressions such as

    defined (X) & X

since the second operator is not evaluated when X is undefined.

The default operator allows undefined expressions to be replaced by another
expression.  The value of

    <expr1> ? [<expr2>]

is equal to the value of <expr1>, if defined; otherwise it is equal to the
value of <expr2>, whether or not the latter is defined.  If the second operand
<expr2> is omitted then the evaluation of the expression is `safe', that is,
GSLgen does not object (when this is feasible) to the result of the expression
being undefined.  This feature can be used in symbol definitions and
substitutions to make GSLgen accept an undefined expression.  See the
description of these instructions for details.

The safe comparative operators return the same result as their equivalent
comparative operators when both operands are defined.  If one or both 
operator is undefined, the safe operators return FALSE while the normal
operators produce an error.  Notice that `a ?<> b' returns TRUE if both
a and b are defined and they are not equal and FALSE otherwise.

If an operand is not a constant then its type depends its value; if it looks
like a number then it is treated as a number, otherwise it is treated as a
string.

Generally, additive, multiplicative and logical operators only apply to
numeric operands.  There are two cases where an arithmetic operator can
apply to string values:

+:
    "ABC" + "DEF" results in "ABCDEF"
*:
    "AB" * 3 results in "ABABAB"

Built-In Functions
------------------

count  ([<scope> .] <child>, <expr>):
    counts the number of children of the supplied or most recently opened scope
    of the given name.  If an expression is specified, it is treated as
    a condition to determine which children are counted.  In this case,
    a new scope `COUNT' is implicitly defined while the condition is
    evaluated.  For example: count (ITEM, COUNT.NAME = "ABC")
    returns the number of children of the most recently opened scope whose
    attribute NAME has the value `ABC'.
index  ([<scope>]):
    returns the index of the item associated with the supplied or most
    recently opened scope.  This differs from the item function in
    that the  index number is assigned after filtering (`by') and
    sorting (`where'), and is undefined withing `by' and `where'
    clauses.  See the description of the `for' command.
item   ([<scope>]):
    returns the item number corresponding to the supplied or most
    recently opened scope.  This differs from the index function in
    that the item number is unaffected by sorting or filtering, and is
    available for use within a `where' or `by' clause.  scope.  See
    the description of the `for' command.
name ([<scope>]):
    returns the name of the XML item currently associated with the supplied
    or most recently opened scope.  See the description of the `for' command.
exists (<FileName>):
    returns a logical value (1 or 0) depending on whether a file of the given
    name exists of not.
timestamp (<FileName>):
    returns the modification time of the file as a sixteen-character string
    CCYYMMDDHHMMSS00; undefined if the file does not exist.
defined ([Ident .] Ident):
    returns a logical value (1 or 0) depending on whether the specified
    identifier is defined or not.
env (var):
    returns the value of an environment variable.
length (string):
    returns the length of a string (or number considered as a string).
substr (string, start, end, length):
    returns a substring of the given string.  This may be used in a number of
    ways:
    substr (string, start, end, )    - specify start and end offsets
    substr (string, start, , length) - specify start offset and length
    substr (string, , end, length)   - specify end offset and length
    substr (string, start, , )       - end of string from start offset
    substr (string, , end, )         - same as substr (0, end, )
    substr (string, , , length)      - end of string of given length
trim (string):
    trims a string by removing leading and trailing white space.
justify (string, width, prefix):
    justifies the string according to the specified width, prefixing each
    line by the string `prefix'.
macro (name):
    returns a logical value (1 or 0) depending on whether a macro or function
    with the given name is defined or not.
deleted ([<scope>]):
    returns a logical value (1 or 0) depending on whether the XML item
    associated with the specified scope has been deleted.

Template and Script Modes
-------------------------

GSL is useful as both a template and a scripting language.  In template mode,
the default mode when GSLgen starts with an XML file, script lines begin with
a point (`.') and all other lines are template lines.  In script mode, the
default mode when GSLgen starts with a GSL script, template
lines begin with a `>' (not necessarily in the first column) and all other
lines are script lines.  You can perform exactly the same operations in
template and script modes - the only difference is convenience for the type
of application.

You can change between template and script mode with the `template' and
`endtemplate' commands.  See the description of these commands below for 
details.

Template Lines
--------------

The simplest template line is just text, which is copied verbatim
to the current output file.  If no output file has been opened, or if the
last output file has been closed, the output is copied to the standard
output.

If the last character of an template line is a backslash (`\') then
the line is output with no line terminator; otherwise a line
terminator follows the template line.  A backslash followed by another
character is generally replaced by that character; this allows
characters which would normally be interpreted as script commands to
be output literally.  There is one exception: `\n' is replaced by a
line break.  To output a backslash, use a double-backslash (`\\').

In template mode an template line is any line which does not begin with a
point (`.').  If an template line must begin with a point, use a backslash
immediately before the point.

In script mode, an template line begins with a greater-than sign (`>'),
which is dropped before the line in output.

Script Lines
------------

In template mode, these are introduced by a point (`.') as the first
non-space character in the line.  In script mode, any line that does
not begin with a greater-than sign (`>') is a command line.  In script
mode, a script line may also begin with a point; this allows script
commands to work in case the current mode is unknown.

The script commands are described below.

If a script command line ends with a backslash (`\') then the following 
script line is treated as a continuation of the current line.

Comments
--------

There are three ways to include comments in GSL scripts.  The first is
to place a hyphen (`-') immediately after the point (`.') in a
template mode or as the first character in script mode.  The second is
to place a hash (`#') after a GSL command.  Any characters following
the hyphen are ignored by GSLGen.  The third way (pace Tony Blair) is
to enclose comment text (which may continue over more than one line)
inside comment markers (`/*' and `*/') just as in C.  However if
GSLGen finds these characters in a template line (but not inside a
substitution) it assumes that they are destined for output, so does
not treat them as a comment.

Examples:

    .- This entire line is a comment

    .output "file"  # This is a trailing comment

    .output /* This is an embedded 
    multi-line comment */ "file"

    If this is a template line then /* this is not a comment */

    $("but "/* this is */)

Substituting Symbols and Expressions
------------------------------------

At any point within a template line, and in many places (described
below) in a script line, a substitute construct may be used instead of
literal text.  The format for expression subsitution is:

    $( <expr> [% format] [: pretty-print] )

The order of the format and pretty-print modifiers is not important.

If the expression has a default operator with no second operand, and its
result is undefined then the substitution resolves to an empty string.

If a format string is provided, it is used to format the result before
continuing.  The format string is similar to that used by the printf
function in C.  It must contain exactly one conversion specification,
consisting of zero or more of the flags `#', `0', `-', ` ' and `+', an
optional minimem field width, an optional precision consisting of a
point (`.') followed by an optional number, and a mandatory conversion
specifier among the following: `d', `i', `o', `u', `x', `X', `e', `E',
`f', `g', `c' and `s'.  The data are always converted to the appropriate
type (one of long int, double, char or char *) for the conversion string.
Note that not all legal C format strings are allowed in GSL.

The pretty-print modifier specifies how case modification and replacement
of certain characters takes place.  The valid pretty-print modifiers (not
case-sensitive) are:

UPPER:
    UPPER CASE
lower:
    lower case
Neat:
    Neat Case Modification
c:
    substitute_non_alpha_to_make_c_identifier
cobol:
    SUBSTITUTE-NON-ALPHA-TO-MAKE-COBOL-IDENTIFIER

More than one pretty-print modifier may be specified; they should be
separated by commas.

If GSLgen is in ignore case mode, and a substition expression consists
of a single identifier and no case-modifier is specified (c or cobol
may still be specified), the case in which the identifier name is
specified is used as an example to determine whether the case of the
result should be modified to UPPER, lower or Neat.  A final exception
is that if an empty pretty-print string is provided, no case
modification is performed.

Some examples:  Assume the identifier IDENT has the value `IDENT value'
and identifer XXX is undefined.

$(XXX):
    produces a run-time GSLgen error: Undefined expression.
$(XXX?"Undefined"):
    `Undefined'
$(XXX?):
    `'
$(IDENT%12s):
    ` IDENT VALUE'
$(ident:upper):
    `IDENT VALUE'
$(Ident):
    `Ident Value'
$(ident:c):
    `ident_value'
$(IDENT:):
    `IDENT value'
$(1 + 1):
    `2'

What You Can Substitute
-----------------------

A substitution can appear at any place inside straight text (template line
or string constant) or an operand in an expression.  It can also replace a
single name in an identifier specification, but not a point (`.') or member
(`->').

Some examples:  Assume the identifier IDENT has the value `NUM'
and identifer NUM has the value `1'.

$($(ident)):
    `1'
$($(ident)).NAME:
    `1.NAME'  This may used in another expression as an identifer.
$(ident)+1:
    `NUM1'
$($(ident))+1:
    `2'


Shuffle
-------

GSLgen can help to keep code neat by enlarging or shrinking white space
so that column numbers match as far as possible between the script and
the output file.  For instance, in the value of the identifier X is
ABCDEF then:

    $(X)   .

evaluates to

    ABCDEF .

but

    $(X?"Undefined") .

evaluates to

    ABCDEF .

The shuffle algorithm uses a parameter `shuffle' (actually an
attribute of the global scope) whose numeric value influences the
operation.  It expands a block of white space longer than `shuffle' as
much as necessary so that the text following the white space is output
in the same column.  It also shrinks white space down to a minimum of
`shuffle' to make space for text preceeding the white space.  If
`shuffle' is zero, then shuffle is disabled.  The default value of
`shuffle' is 1; this is the value which produces the results shown
above.

If the current output ends with a backslash, then the shuffle continues on
the following line.  Thus

    $(X?"Undefined")\\
             .

evaluates to

    ABCDEF   .

Shuffle can cause problems in some cases, for example when outputting
literal text where the size of white space is important.  In this case
shuffle should be disabled with

    .shuffle = 0

COBOL
-----

GSLgen helps you make neat COBOL code by automatically filling the first
six characters of each line with the four-digit line number followed 
by two zeroes.  To enable this function, define an attribute `cobol' of the
root item either using

    .cobol = 1

or

    gslgen -cobol etc.

when you invoke GSLgen, or even (yuk) define an attribute COBOL right in
your XML file.

Predefined Identifiers
----------------------

There are some identifiers whose value is maintained by GSLgen.  They are
defined as attributes of the global item.

script:
  The name of GSL or template script file currently being processed.
filename:
  The name of the XML file being processed.
outfile:
  The name of the current output file; undefined if there is none.
line:
  The line number of the line currently being output to the output file.
me:
  The name of the current application: gslgen.
version:
  The version of the current application.
date:
  The current date in the format YYYY/MM/DD
time:
  The current time in the format hh:mm:ss


Script Commands
***************

Output File Manipulation
========================

.output
-------
    .output <filename>

closes the current output file, if one is open, and opens a new one.

Examples:

    .output "myfile.c"
    .output FILENAME

where FILENAME is an identifier whose value is the desired file name.

.append
-------
    .append <filename>

closes the current output file, if one is open, and
opens a previously existing one and prepares to extend it.

See the description of the output command for examples.

.close
------
    .close

closes the current output file, if one is open.

.literal
--------
    .literal (from <filename> | <expr> || << <terminator>)

Copies text directly to the output file, without substition.  The text
can come from another file, a GSL expression, or from lines in the
script, ending with a line beginning with the specified terminator.

Examples:

    .literal from "file.txt"

    .literal "whatever you want"

    .literal << .endliteral
    Lines are now copied without substitution of
    things like $(abc).
    .endliteral

Control Structures
==================

.for
----
    .for [[<extended-scope>] .] <name> [as <alias>] [where <expr>] [by <expr>]
    .for  [<extended-scope>] .         [as <alias>] [where <expr>] [by <expr>]

opens a scope and introduces a loop.  The following block of code is
processed once for each item specified.  If no scope if specified, the
most recently opened scope is assumed.  The items processed are those
children of the XML item corresponding to this scope.  If the first
form is used only children with the specified name are processed; if
the second form is used, all children are processed.

The alias allows you to give the new scope a name other than the
specified item name; use this when you nest scopes which would
otherwise have the same name or to supply a scope name when using the
second form.

The where clause allows you to specify a condition which must be
satisfied for the code to be processed; the expression is evaluated
before any processing occurs.

The by clause allows you to sort the items according to the result of
evaluating the expression for each item.  If no by clause is specified
the items are processed from the oldest to the youngest, the same
order in which they are described in the XML file.

The expressions in the where and by clauses are evaluated within the
new scope.  This means that they can access attributes of the iterating
item.

During the evaluation of the `by' and `where' expressions, as well as
during the processing of the code, the function `item (name)' returns
the number of the child (1, 2, ...) of the current item.  This number
is associated with the XML item itself and is not affected by a `by'
or `where' clause.

Within the loop, but not within `by' and `where' expressions, the function
`index (name)' returns the index of the current iteration.  This is associated
with the loop, so that it always takes consecutive values.

.endfor
-------
    .endfor

terminates a .for loop, closing the scope.


Examples:

    .for RECORD.FIELD by NAME
    $(FIELD.NAME)
    .endfor

outputs the names of the fields of the current record, sorted in alphabetical
order.

    .for FIELD where item () = 2
    something
    .endfor

processes only the second item named FIELD.

.if
---
    .if <expr>

starts conditional processing of the following block of code if the result
of evaluating the expression is non-zero.

.elsif
------

    .elsif <expr>

may follow an `if' construct.  Any number of `elsif' constructs may be used.

.else
-----

    .else

may follow an `if' or `elsif' construct.  The following block of code is
processed if the logical value of all the expressions is FALSE.

.endif
------
    .endif

terminates a conditional processing construct.

Examples:

    .if NAME = "JAMES"
    something
    .elsif NAME = "JAIME"
    something else
    .else
    everything else
    .endif

.while
------
    .while <expr>

introduces a loop.  The following block of code is processed repeatedly as long
as the expression evaluates to a logical value of TRUE, that is not equal to
zero.  Expression evaluation takes place before the code is processed, so that
the code will never be processed if the expression evaluates to FALSE the first
time.

.endwhile
---------
    .endwhile

terminates a `while' loop.

Examples:

    .define I = 0
    .while I < 5
    loop iteration number $(I)
    .endwhile

.next
-----
    .next

inside a `for' or `while' loop causes immediate iteration, skipping execution
of any code between the `next' command and the `endfor' or `endwhile'
statement.

.last
-----
    .last

inside a `for' or `while' loop causes the loop to terminate iteration
immediately.  Control passes to the line following the `endfor' or `endwhile'
statement.

Symbol Definition
=================

.define
-------

    .[define] <identifier> [<operator>]= [ <expr> ] 

defines or undefines an XML attribute or item value.  Note that the word
`define' is itself optional; any GSL line which does not begin with a
reserved GSL word is an implied `define'.  There are several different forms,
described below:

If the scope is omitted from the identifier specification, GSLgen searches
open scopes for one in which an attribute of the specified name exists.  If
none is found, it uses the first open scope, which effectively makes 
the identifier a global variable.

If the name is omitted from an identifier, the value of the XML item is 
modified, rather than that of an attribute.

If neither scope nor name is specified, GSLgen defines the value of the XML
item associated with the most recently open scope.  This removes any existing
value and appends the new value after any children.

If the expression is left empty then the symbol becomes undefined.  If the
expression ends with a default operator `?' but no default expression then
an undefined expression causes the symbol to becume undefined rather than
producing a runtime error.

If a multiplicative, additive or default operator is specified then the
value assigned to the symbol is the result of that operator and the
supplied expression to the former value of the operator.

Examples:

    .define x = 1

assigns the value 1 to the identifier x in the most recently opened 
open scope where x is already defined, or in the global scope if x is
undefined.

    .define ->child. = "Value"

assigns the string `Value' to the value of the first XML item child
which is a child of the XML item corresponding to the most recently 
opened scope.

    .x *= 2

multiplies the value of the identifier x by 2.

    .x ?= y ? z ?

does nothing if x is already defined; otherwise assigns it the value of y,
or if y is undefined then the value of z, or if z is undefined, x remains
undefined.

XML Manipulation
================

.new
----

    .new <name> [to <extended-scope> | before <before-scope> | after <after-scope>] [as <alias>] 

creates a new XML item.  This allows you to build new items in the
data tree.  The new item has the specified name and is a child of the
XML item corresponding to th specified scope, or the most recently
opened scope if none is specified.  If a `before-scope' or
`after-scope' is specified, then then it must be the name of an open
scope corresponding to a child of <scope>, and the new item is
inserted just before <before-scope> or just after <after-scope>;
otherwise the  new item is inserted after any existing children.  The
construct creates a new scope with the name specified by the alias or
the item name if there is no alias.  The following block of code is
processed exactly once within this new scope.  It would typically done
some attributes of the new XML item.  These values can then be
retrieved during a future iteration of a `for' construct through the
new item.

.endnew
-------

    .endnew

terminates a `new' construct.

Examples:

    .new RECORD.FIELD
    .    define FIELD.NAME = "NEW FIELD"
    .endnew

    .for RECORD.FIELD as OLDFIELD where NAME = "OLD FIELD"
    .    new RECORD.FIELD before OLDFIELD
    .        define FIELD.NAME = "NEW FIELD"
    .    endnew
    .endfor

.delete
-------
    .delete <extended-scope>


deletes the XML item (and any descendents) corresponding to the specified
scope.  Once the item has been deleted, any attempt to reference it produces
an error.

The function `delete (name)' allows you to determine whether the XML item
associated with a scope has been deleted.

Examples:

    .for RECORD.FIELD where TYPE = "COMMENT"
    .    delete FIELD
    .endfor

.copy
-----
    .copy [<from-scope>] [ to <parent-scope> | after <after-scope> | before <before-scope> ] [as <name>]


makes a copy the XML item associated with <from-scope> (or the most
recently opened scope if not specified) at the point 
specified by either the new parent (`to') or new sibling (`after' or
`before'), or as a child of the XML item of the most recently opened
scope if no parent of sibling is specified.  The `as' clause allows
you to the new item to have a different name from the old item.

Examples:

    .for DATABASE.TABLE
    .    for RECORD.FIELD
    .        copy FIELD to TABLE
    .    endfor
    .endfor

.move
-----
    .move [<from-scope>] [ to <parent-scope> | after <after-ident> | before <before-ident> ] [as <name>]


re-attaches an XML item at the point specified by  a `to', `after' or
`before' clause, renaming it to the name specified in the
`as' clause, if specified.

GSLgen detects any attempt to make an XML item its own descendent.

Note that moving an XML does not invalidate any scope associated with it.
If the moved XML item is associated with a future iteration of a `for' loop,
the iteration will still take place even if the item is no longer a child
of the extended scope from the `for' instruction.

Examples:

    .for TABLE.RECORD
    .    for RECORD.FIELD
    .        move FIELD to RECORD
    .    endfor
    .endfor

.sort
-----

    .sort [[<extended-scope>] .] [<name>] [as <alias>] by <expr>

Sorts the specified XML items.  A scope is created with each item in
turn and is used to evaluate the expression.  The result is then used
to sort the items.  The `as' clause allows you to give the created
scope a different name.  After execution, the specified XML items are
in order and after any other children of the same parent.

.load
-----
    .load <filename> [ to <parent-scope> | after <after-ident> | before <before-ident> ] [as <name>]


Loads the contents of an XML file at the place specified by a `to', `after' or
`before' clause, renaming the items to the name specified in the `as'
clause, if specified.

Note that `load' is deprecated.  Use `xml' instead.

.xml
----
    .xml [ to <parent-scope> | after <after-ident> | before <before-ident> ] [as <name>] (from <filename> | <expr> || << <terminator>)


imports XML data into the the specified point.  The data can come from a file,
an expression, or from lines in the script, ending with a line beginning with
the specified terminator.  Note that in this form, GSLgen uses the lines
literally, without substitution.

Examples:

    .xml from "data.xml"

    .xml to RECORD '<field name="date"/><field name="time"/>'

    .xml after SISTER << .endxml
    <text>
    All this text is used literally even though it contains stuff
    that looks like a substitution, eg $(abc).
    </text>
    .endxml

.save
-----

    .save <extended-scope> as <filename>

creates an XML file representing the XML item corresponding to the specified
scope.  This recursively includes all child items.

Script Manipulation
===================

.include
--------

    .include <filename>

includes another script file.  Deprecated - see `gsl'

.gsl
----

    .gsl from <filename>
    .gsl <expr>

interprets the contents of the specified file or expression as GSL,
just as though it were part of the script.

Examples:

    .gsl "header.gsl"
    .gsl GSL.TEXT

.template
---------
    .template (0 | 1)


Turns template mode on or off.

.endtemplate
------------

Terminates the block introduced by a `template' instruction.

Macros and Functions
====================

Macros and functions are pieces of GSL which can be invoked with parameters.
The only difference between a macro and as function is that macros are
interpreted in template mode and functions in script mode.

.macro
------
    .macro <name> [(<param> [, <param>] ...)]


introduces a macro definition with the specified name.

.endmacro
---------
    .endmacro

terminates a macro definition.

.function
---------
   .function <name> [([<param>] [, <param>] ...)]


introduces a function definition with the specified name.

.endfunction
------------
    .endfunction

terminates a function definition.

.invoke
-------
    .[invoke] <name> [([<expr>] [, [<expr>]])] ...)]


causes a previously defined macro or function to be processed.  Note that
the keyword `invoke' is optional, so that a function can be invoked by simply
giving its name and a (possibly empty) parameter list.

This creates a special scope with the name of the macro or function,
and attributes corresponding to the parameters value of the
parameters.  This scope does not count in numeric scope specifications
and cannot have children.  It can be used to define local variables,
but must in this case be specified by name.

The number of expressions (or empty expressions) must match exactly
the number of parameters in the definition.  An empty expression or an
expression whose value is undefined causes the corresponding parameter
to be undefined during processing of the macro code.

Examples:

    .macro echotwice (text)
    .    echo text
    .    echo text
    .endmacro
    ...
    .echotwice ("Hello")

    .function recursive (N)
        recursive.localvar = N - 1
        recursive (localvar)
    .endfunction

    .function assign (dest, source)
        .$(dest) = source
    .endfunction

Miscellaneous
=============

.echo
-----

    .echo <expr>

outputs the given expression to the standard output.

.abort
------

    .abort <expr>

outputs the given expression to the standard output and halts GSLgen
operation.


