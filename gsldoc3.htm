<HTML><HEAD><!--Revised: 10 Apr, 2000 By: iMatix-->
<TITLE>Using GSLgen</TITLE></HEAD>
<BODY BGCOLOR="DARKBLUE">
<CENTER><TABLE cellspacing=0 cellpadding=0 border=0 WIDTH=800 BGCOLOR="WHITE"><TR><TD WIDTH=50>&nbsp;</TD><TD>
<TABLE border=0 WIDTH=100%><TR><TD ALIGN=LEFT>
 | <A HREF="/index.htm"> iMatix home page</A><BR>
 | <A href="gsldoc.htm">&lt;&lt;</A> | <A href="gsldoc2.htm">&lt;</A>
 | <A href="gsldoc4.htm">&gt;</A> | <A href="gsldoc5.htm">&gt;&gt;</A>
</TD><TD ALIGN=RIGHT>
<IMG SRC="gslgen.gif" ALT="GSLgen" WIDTH=100 HEIGHT=75 ALIGN=RIGHT HSPACE=10>
<FONT SIZE=4><B>GSLgen</B><BR><FONT SIZE=2>Version 2.0</TD></TR>
</TABLE>
<HR><FONT SIZE=-1 FACE="Arial">
<H1><A NAME="TOC4">Using GSLgen</A></H1>

<H3><A NAME="TOC5">Command-line Syntax</A></H3>

<P>To run GSLgen, use the following syntax
<PRE>  gslgen -&lt;option&gt; ... -&lt;attr&gt;[:&lt;value&gt;] ... filename ...
</PRE>

<P>If the filename has no extension, GSLgen tries to find an XML file with
that name, or with the extension `.xml' (recognised by the &lt;?xml... tag on
the first line).  If it finds no XML file it tries to find a file with
that name or the extension `.gsl', which it interprets as a GSL file.

<P>Options currently recognised by GSLgen are:

<DL>
<DT><B>q, quiet</B>
  <DD>Suppresses copyright and other messages from GSLgen.
</DL>

<P>Command-line attributes are loaded with an XML file and are available to
a script.  This allows paramaters to be passed from the command line to the
script.  The attribute script can be set to the name of a GSL file to be
interpreted.

<P>If GSLgen found an XML file, it loads it, then looks for an attribute named
script of the top-level item.  This name is used to find a GSL script to
interpret.  If GSLgen found a GSL file, it begins interpreting it without
loading an XML file.

<H3><A NAME="TOC6">Getting Started</A></H3>

<P>How do I use GSLgen?

<UL>
<LI>If you have an XML file entitled test.xml, the simplest way to
invoke GSLgen is
</UL>
<PRE>  gslgen test
</PRE>
<UL>
<LI>In this case the script must be defined as an attribute of the top-level
  item defined in test.xml.  If this is not the case, or if you wish to
  use a different script, use the form
</UL>
<PRE>  gslgen -script:xxxxxxx.gsl test.xml
</PRE>

<H3><A NAME="TOC7">A Hello World Example</A></H3>

<P>Try a `hello world' test:

<P>Create a file called `hello.gsl':

<PRE>  echo "hello world"
</PRE>

<P>Run this using `gslgen hello'.  This shows a trivial GSL script running
without any XML data.  The script does some work, and ends.  Let's look at
how we process an XML data file.

<P>Create a file called `hello.xml':

<PRE>  &lt;HWML&gt;
  &lt;WORLD NAME="World"&gt;
      &lt;HELLO NAME="Hello" /&gt;
  &lt;/WORLD&gt;
  &lt;/HWML&gt;
</PRE>

<P>Change `hello.gsl' (we now use a dot in the first column):

<PRE>  .for world
  .  for hello
  .    echo "$(name) $(world.name)"
  .  endfor
  .endfor
</PRE>

<P>Then, run GSLgen:

<PRE>  gslgen -script:hello.gsl hello.xml
</PRE>

<H3><A NAME="TOC8">A More Complex Example</A></H3>

<P>This is a script which generates a simple DOS batch file to install programs
by copying them into various directories.  It's something you might want to
generate for specific projects:

<PRE>  .-
  .- install.gsl   Generates install script from install.xml
  .-
  .output "install.bat"
  @echo off
  rem generated by gslgen from install.xml, $(script)
  .for file
  .  if    type = "binary"
  echo $(name) -- \\usr\\bin
  copy $(name) \\usr\\bin &gt;nul
  .  elsif type = "script"
  echo $(name) -- \\usr\\lib
  copy $(name) \\usr\\lib &gt;nul
  .  elsif type = "doc"
  echo $(name) -- \\usr\\doc
  copy $(name) \\usr\\doc &gt;nul
  .  endif
  copy $(name) install &gt;nul
  .endfor
</PRE>

<P>The input is an XML file like this:

<PRE>  &lt;?xml version="1.0"?&gt;
  &lt;INSTALL script="install.gsl"&gt;
  &lt;FILE name="gslgen.exe"  type="binary" /&gt;
  &lt;FILE name="gslgen.htm"  type="doc"    /&gt;
  &lt;FILE name="install.gsl" type="script" /&gt;
  &lt;FILE name="hello.gsl"   type="script" /&gt;
  &lt;/INSTALL&gt;
</PRE>

<P>We run GSLgen to process the XML file:

<PRE>  gslgen install
</PRE>

<P>This is the result:

<PRE>  @echo off
  rem generated by gslgen from install.xml, install.gsl
  echo gslgen.exe -- \usr\bin
  copy gslgen.exe \usr\bin &gt;nul
  copy gslgen.exe install &gt;nul
  echo gslgen.htm -- \usr\doc
  copy gslgen.htm \usr\doc &gt;nul
  copy gslgen.htm install &gt;nul
  echo install.gsl -- \usr\lib
  copy install.gsl \usr\lib &gt;nul
  copy install.gsl install &gt;nul
  echo hello.gsl -- \usr\lib
  copy hello.gsl \usr\lib &gt;nul
  copy hello.gsl install &gt;nul
</PRE>

<H3><A NAME="TOC9">What's Going On?</A></H3>

<P>The scripts hello.gsl and install.gsl contain lines with a point (`.')
in the first column.  These are called script lines and contain
instructions to be interpreted.  The script install.gsl also contains
lines which do not begin with a point.  These are called template
lines and contain text to be output when the line is interpreted.
They may also contain substitution symbols which look like the text
`$(name)'.  Notice that each occurrence of the backslash character is
repeated in the script, but not in the output file.  This is because
GSLgen, like many programs, uses the backslash to introduce a special
character, and two backslashes are required to output one backslash.

<P>The `for' instruction requires some explanation; it is the way to
iterate through XML data.  This is somewhat redundant in the case of
`hello.gsl' since there is only one instance of the XML items `WORLD'
and `HELLO'.  The `for' instruction makes available the attributes of
the XML item of the same name.  Thus the attributes `name' and `type'
of the items  named `FILE' in `install.xml' can be used in the lines
between the `for' and corresponding `endfor'.  Notice that in the
first example, the items `WORLD' and `HELLO' both contain an attribute
`NAME' which the script accesses independently by specifying
`$(world.name)' or `$(name)'.  It could also use `$(hello.name)' in
the second case; if the attribute name appears alone then GSLgen
searches for an attribute with that name in all open XML items
beginning with the most recently opened.

<H3><A NAME="TOC10">Another Complex Example</A></H3>

<P>Try this command:

<PRE>  gslgen -script:xmlfile.gsl spfper.dbm
</PRE>

<P>This generates a C function, spfper.c, which handles a data table (in this
case a list of persons) as an XML file, with functions to read, save, and
update data in this table.  This is a good example of a complex GSL script,
and one that is used in real life to handle data objects in iMatix Studio.

<HR><TABLE WIDTH=100%><TR><TD ALIGN=LEFT WIDTH=60%>
 | <A href="gsldoc.htm">&lt;&lt;</A> | <A href="gsldoc2.htm">&lt;</A>
 | <A href="gsldoc4.htm">&gt;</A> | <A href="gsldoc5.htm">&gt;&gt;</A>
<BR><FONT SIZE=2>
| <A href="gsldoc.htm">The Generator Script Language</A>
| <A href="gsldoc1.htm">Introduction</A>
| <A href="gsldoc2.htm">Installing GSLgen</A>
| <EM>Using GSLgen</EM>
| <A href="gsldoc4.htm">The General Schema Language (GSL)</A>
| <A href="gsldoc5.htm">Script Commands</A>
</TD><TD ALIGN=RIGHT NOWRAP>
<A HREF="/index.htm">
<IMG SRC="im0096c.gif" WIDTH=96 HEIGHT=36 ALT="iMatix" BORDER=0>
</A>
<BR><FONT SIZE=2>Copyright &#169; 1996-2000 iMatix</TD></TR></TABLE>
</td></tr></table>
</BODY></HTML>
